---
title: 网络相关
layout: ../../../layouts/PostLayout.astro
---

## **Https**

### **原理，整个实现的过程，流程。每一步都做了什么事情**

Https的设计目的：防篡改，防窃听

- 通过非对称加密，进行对称密钥的传递
  - 建立TCP链接
  - 客户端发起HTTPS请求
  - 服务端去CA机构申请数字证书，对数字证书生成摘要，将摘要使用服务端的私钥签名，发给客户端
    - 证书中包含了服务器的公钥、服务器的域名、证书颁发机构、证书有效期等信息。
  - 客户端拿到数字证书后，验证合法性：再生成摘要，并使用服务端的公钥解密签名，对比摘要是否相同（防篡改）
  - 如果验证通过，客户端生成一个对称密钥，使用服务端的公钥签名发送给服务端
  - 服务端收到对称密钥后，用私钥解密，拿到对称密钥后，客户端和服务端使用对称密钥进行加密通信
- 后通过对称密钥，进行数据包的传递

### **不用Https如何防止第三方植入广告（被攻击者拦截攻击）**

CSP，此时如果攻击者想要实施攻击，还需要控制一台在白名单中的主机

### 根证书存在哪里？

存在操作系统中

### 用过抓包工具吗？抓HTTPS的时候它有没有让你装证书，装的是什么证书？为什么装了这个证书之后抓包软件就能作为中间人劫持到内容了？

抓包工具能够抓包的关键是客户端会**往系统受信任的根证书列表中导入抓包工具生成的证书**，而这个证书会被浏览器信任，也就是抓包工具给自己创建了一个认证中心 CA，客户端拿着中间人签发的证书去中间人自己的 CA 去认证，当然认为这个证书是有效的。

## **从输入url到展示界面会发生什么事情**

dns解析出ip

检查浏览器是否有缓存

- 如果命中强缓存，直接取本地磁盘的html，状态码为200
- 如果协商缓存，询问服务器资源是否更改，304表示无更改，

请求资源，解析html

- DOM
- CSSOM

渲染页面

下载js脚本

- defer： 下载后要等到Content loaded再执行
- async：标记这个脚本是完全独立的

执行js脚本

发起网络请求

处理事件循环等异步逻辑

### **浏览器是怎么加载资源的**

- preload 和 prefetch的区别：preload是把这个资源优先级放到最低，等浏览器空闲了再去加载。而prefetch会预先发起这个请求

## 讲一讲http1.0 1.1 2.0 3.0分别有什么区别和特性

- **1.0：**

无法复用链接，HTTP对于同一个域名只能建立6个TCP连接

队头阻塞，假设上一个请求到不了，下一个请求就永远到不了

- **1.1：**

添加HTTP缓存机制

把队头阻塞（先进先出，挪到了客户端）

- **2.0：**

多路复用

二进制传输

头部压缩

服务端推送

- **3.0：**

QUIC：

把RTT变成了0

使用UDP来实现了TCP的特性

向前纠错机制，如果某个数据包丢失了，能够根据其他数据包中的冗余数据来恢复

Cookie的http-only

### HTTP缓存原理

答强缓存和协商缓存即可，并记住几个字段

- Expires：绝对时间
- Cache-control max-age：相对时间
- If-Modified-Since：修改时间，协商缓存
- e-tag：文件标识，修改了会变

QUIC协议

## TCP/IP

### 建立了TCP连接之后，服务端是如何探测客户端有多大的网络带宽，来决定给他发多大的数据，以多快的速度的。

答：拥塞控制机制，滑动窗口

### 客户端丢一个数据包，有没有什么机制决定什么时间点服务端没接收到

TTL，

### TTL表示什么？

经过的跳数

### HTTP报头里面有什么内容

### 如何使用UDP来模拟TCP

使用QUIC，通过阻塞部分流解决了包裹丢失的问题，让连接在不同网络上的建立变得简单

通过仅仅阻塞部分流解决了包裹丢失这个问题，让连接在不同网络上建立变得更简单

## 网络不是完全一对一透明的，NAT后面，远端服务器在回包的时候，是如何透过一层又一层的NAT，返回到指定的客户端上面去的

### 讲讲TCP协议的 三次握手和四次挥手

## OSI七层模型

- 应用层（电子邮件等应用）
- 表示层（数据表示）
- 会话层（建立、维持和终止会话，会话可能支持单工，半双工或全双工模式。）
- 传输层（TCPIP 报文）
- 网络层（数据包）
- 数据链路层（一帧）
- 物理层（电缆等物理设备）

## HTTP 1.0 1.1 2.0 3.0

### HTTP 协议，为什么有的业务要去使用 HTTP2，HTTP 1.1 和 HTTP2有什么区别。

HTTP1.1 存在的问题：

- 同一个域名的TCP连接数量限制

对于同一个域名，浏览器最多只能发6-8个请求，因此出现了域名分片技术，即把资源分到不同的域名做并发请求，以此方式来突破限制。但这么做会占用过多的CPU和内存，且对服务器来说也会造成网络拥挤等。

- 线头阻塞

每个TCP连接同时只能处理一个请求，如果上一个响应没返回，后续的请求-响应都会被阻塞

- Header内容多

每次请求Header内容不会变化，没有对应的压缩传输优化方案

- 明文传输不安全
- 为了减少请求数，会做合并文件，雪碧图，资源内联等优化工作，无法使用缓存

HTTP2：

- 使用二进制传输代替明文传输，报文消息被切分成了更小的数据帧
- 多路复用，所有的通信都在一个TCP中完成。消息切分成一个或多个帧在流里传输，传输后进行重组。
- 使用HPACK来进行头部压缩。压缩请求头一些相同的字段
- 服务端推送功能。服务端可以根据请求的资源检查出依赖的其他资源。

## HTTP缓存

### 你对HTTP缓存是怎么理解的。 301，302，304分别代表什么

HTTP 1.0 时代：通常通过Expires 指定资源的过期时间，告诉浏览器在这个时间之前可以直接使用缓存而无需再次请求服务器

HTTP 1.1 时代：

- Cache-control 不依赖于绝对时间，而是使用相对时间。例如max-age = 3600代表资源可以缓存一小时
- Etag 和 last-modified 。在协商缓存时，通过这两个字段可以知道缓存是否进行更新了

状态码：

- 301：永久重定向，表示资源已经永久地被迁移至其他地址
- 302：临时重定向，表示资源暂时被挪到其他地址
- 304：表示协商缓存命中，服务器告知客户端资源未修改，客户端可以直接使用本地缓存

强缓存：浏览器直接从本地缓存中读取资源，无需与服务器通信。没过期直接用，过期了重新拿

协商缓存：当强缓存失效时，浏览器会通过 `If-Modified-Since`（结合 `Last-Modified`）或 `If-None-Match`（结合 `ETag`）向服务器询问资源是否发生变化。若没有变化，则服务器返回 `304` 状态码，浏览器继续使用缓存。

## HTTP状态码

### 常见的HTTP状态码有哪些
